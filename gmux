#!/bin/bash

PGNAME="tman-gmux"
VERSION="v0.0.1"
COMMAND=
TASKDIR=
PRJNAME=
TASKNAME=
ISDEBUG=false

# TODO: add option for config path on CLI
CONFIG_FILE=

COMMITPATT="[ID] PART: MSG"
BRANCHPATT="TYPE/PREFIX-ID_DESC_DATE"

declare -A PGNUNITS


function find_config()
{
    declare -a cfgs=(
        "$HOME/.tman/pgns/gmux.json"
        "$HOME/.config/tman/pgns/gmux.json"
    )

    for cfg in "${cfgs[@]}"; do
        if [ -f "$cfg" ]; then
            CONFIG_FILE="$cfg"
            break
        fi
    done
}

function unit_load()
{
    local fname="$1"

    # Check if gmux unit file exists to load units
    [ ! -f "$fname" ] && return 0

    while IFS=" : " read -r key val; do
        [[ -n "$key" ]] && PGNUNITS["$key"]="$val"  # Skip empty lines
    done < "$fname"
}

function unit_save()
{
    local fname="$1"

    # Empty the file first
    : > "$fname"

    for unit in "${!PGNUNITS[@]}"; do
        echo "$unit : ${PGNUNITS["$unit"]}" >> "$fname"
    done
}

function unit_set()
{
    local fname="$1"
    local ukey="$2"
    local uval="$3"

    unit_load "$fname"
    PGNUNITS["$ukey"]="$uval"
    unit_save "$fname"
}

function elog()
{
    echo "$PGNAME:" "$@" >&2
}

function dlog()
{
    if [ "$ISDEBUG" == true ]; then
        echo "$PGNAME:" "$@"
    fi
}

function usage()
{
cat << EOF
Usage: tman gmux [OPTION]...
    commit      create task commit based on commit pattern
    delete      delete task branch
    help        show this help message and exit
    show        show unit values
    push        push task branch to remote repo
    sync        create and update task branch
    rsync       update from romote branch and merge with default branch
EOF
}

# TODO: Add support for config values from gmux.json
# FIXME: add prefix and other project wide stuff
function generate_branch()
{
    #local prjcfg="$1"
    declare -A units  # Declare associative array
    declare -A pgnunits  # Declare associative array
    local branchpatt="$BRANCHPATT"

    while IFS=" : " read -r key val; do
        [[ -n "$key" ]] && units["$key"]="$val"  # Skip empty lines
    done < "$SYSFILE"

    while IFS="=" read -r key val; do
        [[ -n "$key" ]] && pgnunits["$key"]="$val"  # Skip empty lines
        #dlog "-- pgnunits: $key -> $val"
    done < <(jq -r 'to_entries[] | "\(.key)=\(.value)"' <<< "$repo")


    # TODO: set default values
    units["id"]="$TASKNAME"
    units["prefix"]="$(jq -cr ".$PRJNAME.prefix" "$CONFIG_FILE")"
    [[ ${units["prefix"]} = "null" ]] && units["prefix"]="PREFIX"

    IFS='-/_' read -ra items <<< "$branchpatt"
    for item in "${items[@]}"; do
        lower_item="${item,,}" # to lower case
        branchpatt="${branchpatt/$item/${units["$lower_item"]}}"
    done

    # Delete whitespaces in description
    echo "${branchpatt// /_}"
}

function _gmux_init()
{
    local unitdir="$TASKDIR/$PRJNAME/$TASKNAME/.tman/pgn"

    find_config
    [ -f "$CONFIG_FILE" ] && jq empty "$CONFIG_FILE" || exit 1

    # Create necessary files and directories
    if [ ! -d "$unitdir" ]; then
        mkdir -p "$unitdir"
    fi
}

function gmux_commit()
{
    return 0
}

function gmux_delete()
{
    REPODIR="$TASKDIR/$PRJNAME/$TASKNAME"
    SYSFILE="$REPODIR/.tman/unit"
    PGNFILE="$REPODIR/.tman/pgn/gun"
    REPOS="$(jq -c ".$PRJNAME.repos[]" "$CONFIG_FILE")"
    BRANCH_GEN=$(generate_branch)
    BRANCH_ORG="$(cat "$PGNFILE" | grep branch | tr -s ' ' | cut -f 3 -d ' ')"

    while read -r repo; do
        declare -A pgnunits  # Declare associative array

        # Read plugin units
        while IFS="=" read -r key val; do
            [[ -n "$key" ]] && pgnunits["$key"]="$val"  # Skip empty lines
            #dlog "-- pgnunits: $key -> $val"
        done < <(jq -r 'to_entries[] | "\(.key)=\(.value)"' <<< "$repo")
        [[ ! -v "${pgnunits["path"]}" ]] && pgnunits["path"]="$PGNDIRBASE"
        local repodir="$TASKDIR/$PRJNAME/$TASKNAME/${pgnunits["name"]}"

        CHANGES="$(git -C "$repodir" status --porcelain --untracked-files=all)"
        if [ -z "$CHANGES" ]; then
            git -C "$repodir" checkout -q "${pgnunits["branch"]}"
            git -C "$repodir" branch -q -D "$BRANCH_ORG"
        else
            elog "'${pgnunits["branch"]}': could not delete task branch cuz of uncommited changes"
        fi
        # TODO: delete branch name from gmux unit file ??
    done <<< "$REPOS"
}

function gmux_help()
{
    usage
}

# TODO: add merge strategies: merge, rebase, cherry-pick
function gmux_merge()
{
    MERGEMODE="$1"
    REPODIR="$TASKDIR/$PRJNAME/$TASKNAME"
    SYSFILE="$REPODIR/.tman/unit"
    PGNFILE="$REPODIR/.tman/pgn/gun"
    REPOS="$(jq -c ".$PRJNAME.repos[]" "$CONFIG_FILE")"
    IFS=" : " read -r key BRANCH_ORG < "$PGNFILE"
    #[[ ! -v "${pgnunits["prefix"]}" ]] && pgnunits["prefix"]="CPR"

    if [ -z "$MERGEMODE" ]; then
        MERGEMODE="-r" # default is rebase mode
    elif [ "$MERGEMODE" != "-m" ] && [ "$MERGEMODE" != "-c" ]; then
        elog "'$MERGEMODE': no such merge option"
    fi

    while read -r repo; do
        declare -A pgnunits  # Declare associative array

        # Read plugin units
        while IFS="=" read -r key val; do
            [[ -n "$key" ]] && pgnunits["$key"]="$val"  # Skip empty lines
            #dlog "-- pgnunits: $key -> $val"
        done < <(jq -r 'to_entries[] | "\(.key)=\(.value)"' <<< "$repo")
        [[ ! -v "${pgnunits["path"]}" ]] && pgnunits["path"]="$PGNDIRBASE"

        BRANCH_GEN=$(generate_branch)
        local repodir="$TASKDIR/$PRJNAME/$TASKNAME/${pgnunits["name"]}"

        CHANGES="$(git -C "$repodir" status --porcelain --untracked-files=all)"
        # TODO: show error in case merge conflict occurs
        if [ -z "$CHANGES" ]; then
            git -C "$repodir" checkout -q "${pgnunits["branch"]}"
            if [ "$MERGEMODE" = "-r" ]; then
                git -C "$repodir" rebase -q "$BRANCH_GEN"
            elif [ "$MERGEMODE" = "-m" ]; then
                git -C "$repodir" merge -q "$BRANCH_GEN"
            elif [ "$MERGEMODE" = "-c" ]; then
                elog "under development"
            else
                # TODO: Move option check up
                elog "'$MERGEMODE': no such merge option"
            fi
            git -C "$repodir" checkout -q "$BRANCH_GEN"
        fi
    done <<< "$REPOS"
}

function gmux_push()
{
    echo "under development: update remote repo with task branch"
}


function gmux_show()
{
    cat "$TASKDIR/$PRJNAME/$TASKNAME/.tman/pgn/gun"
}

# TODO: have an error if branch is in unit file but not created in repo
function gmux_sync()
{
    REPODIR="$TASKDIR/$PRJNAME/$TASKNAME"
    SYSFILE="$REPODIR/.tman/unit"
    PGNFILE="$REPODIR/.tman/pgn/gun"
    REPOS="$(jq -c ".$PRJNAME.repos[]" "$CONFIG_FILE")"

    # roach:FIXME: will break a program when I add repo list in there
    [ -f "$PGNFILE" ] && IFS=" : " read -r key BRANCH_ORG < "$PGNFILE"

    while read -r repo; do
        declare -A pgnunits  # Declare associative array

        # Read plugin units
        while IFS="=" read -r key val; do
            [[ -n "$key" ]] && pgnunits["$key"]="$val"  # Skip empty lines
            #dlog "-- pgnunits: $key -> $val"
        done < <(jq -r 'to_entries[] | "\(.key)=\(.value)"' <<< "$repo")
        [[ ! -v "${pgnunits["path"]}" ]] && pgnunits["path"]="$PGNDIRBASE"


        BRANCH_GEN=$(generate_branch)
        local repodir="$TASKDIR/$PRJNAME/$TASKNAME/${pgnunits["name"]}"

        dlog "BRANCH_ORG: $BRANCH_ORG"
        dlog "BRANCH_GEN: $BRANCH_GEN"
        dlog

        # clone repos
        if [ ! -d "${pgnunits["path"]}/${pgnunits["name"]}" ]; then
            dlog "clone repo '${pgnunits["name"]}'"
            git clone -q --recursive "${pgnunits["link"]}" "${pgnunits["path"]}/${pgnunits["name"]}"
        fi

        # symlink 'em to task directory
        if [ ! -L "$repodir" ]; then
            dlog "link repodir: $repodir"
            ln -s "${pgnunits["path"]}/${pgnunits["name"]}" "$repodir"
        fi

        # Create or rename task branch
        # TODO: check for changes in submodules
        # TODO: make sure created branch does not exist yet
        # TODO: add support for submodules
        # TODO: Add case when branch exists but gmux unit file is empty
        CHANGES="$(git -C "$repodir" status --porcelain --untracked-files=all)"
        if [ -z "$CHANGES" ]; then
            if [ -n "$BRANCH_ORG" ] && [ "$BRANCH_ORG" != "$BRANCH_GEN" ]; then
                dlog "rename task branch"
                git -C "$repodir" branch -m "$BRANCH_ORG" "$BRANCH_GEN"
            elif [ -z "$BRANCH_ORG" ]; then
                dlog "create task branch"
                git -C "$repodir" checkout -q -b "$BRANCH_GEN" "${pgnunits["branch"]}"
            elif ! git -C "$repodir" branch -l | grep -q "$BRANCH_GEN"; then
                git -C "$repodir" checkout -q -b "$BRANCH_GEN" "${pgnunits["branch"]}"
            fi

            # Update branch in gmux unit file
            unit_set "$REPODIR/.tman/pgn/gun" "branch" "$BRANCH_GEN"
        else
            elog "$PGNAME: '${pgnunits["name"]}': repo has uncommited changes"
            continue
        fi

        # Switch to task branch
        git -C "$repodir" checkout -q "$BRANCH_GEN"
    done <<< "$REPOS"
}

function gmux_rsync()
{
    REPODIR="$TASKDIR/$PRJNAME/$TASKNAME"
    SYSFILE="$REPODIR/.tman/unit"
    PGNFILE="$REPODIR/.tman/pgn/gun"
    REPOS="$(jq -c ".$PRJNAME.repos[]" "$CONFIG_FILE")"
    BRANCH_GEN=$(generate_branch)
    [ -f "$PGNFILE" ] && IFS=" : " read -r key BRANCH_ORG < "$PGNFILE"

    while read -r repo; do
        declare -A pgnunits  # Declare associative array

        # Read plugin units
        while IFS="=" read -r key val; do
            [[ -n "$key" ]] && pgnunits["$key"]="$val"  # Skip empty lines
            #dlog "-- pgnunits: $key -> $val"
        done < <(jq -r 'to_entries[] | "\(.key)=\(.value)"' <<< "$repo")
        local repodir="$TASKDIR/$PRJNAME/$TASKNAME/${pgnunits["name"]}"

        # TODO: add support for merge tactics: rebase, merge, cherry-pick
        # TODO: what to do if merge conflict occurs??
        # TODO: add support for submodules
        CHANGES="$(git -C "$repodir" status --porcelain --untracked-files=all)"
        if [ -z "$CHANGES" ]; then
            git -C "$repodir" checkout -q "${pgnunits["branch"]}"
            git -C "$repodir" pull -q origin "${pgnunits["branch"]}"
            git -C "$repodir" checkout -q "$BRANCH_ORG"
            git -C "$repodir" rebase -q "${pgnunits["branch"]}"
        else
            elog "'${pgnunits["branch"]}': could not pull from remote branch cuz of uncommited changes"
        fi
    done <<< "$REPOS"
}


# Driver part of the code
OPTS=$(getopt -o di:p:P:T:hV --long debug,prj:,taskid:,pgndir:,taskdir:help,version -n "$PGNAME" -- "$@")
if [ $? -ne 0 ]; then
    #echo "error parsing options" >&2
    exit 1
fi

## Reset the positional parameters to the parsed options
eval set -- "$OPTS"

while true; do
    case "$1" in
        -d)
            ISDEBUG="$2"
            shift 1
            ;;
        -i)
            TASKNAME="$2"
            shift 2
            ;;
        -p)
            PRJNAME="$2"
            shift 2
            ;;
        -P)
            PGNDIRBASE="$2"
            shift 2
            ;;
        -T)
            TASKDIR="$2"
            shift 2
            ;;
        -V)
            echo "$PGNAME: $VERSION"
            exit 0
            ;;
        --)
            shift
            break
            ;;
        *)
            elog "invalid option '$1'"
            exit 1
    esac
done

# TODO: add default command (maybe)
COMMAND="$1"; shift

_gmux_init

if [ -z "$COMMAND" ]; then
    elog "no command passed"
    exit 1
elif [ "$COMMAND" = "commit" ]; then
    gmux_commit "$@"
elif [ "$COMMAND" = "delete" ]; then
    gmux_delete "$@"
elif [ "$COMMAND" = "help" ]; then
    gmux_help "$@"
elif [ "$COMMAND" = "merge" ]; then
    gmux_merge "$@"
elif [ "$COMMAND" = "push" ]; then
    gmux_push "$@"
elif [ "$COMMAND" = "show" ]; then
    gmux_show "$@"
elif [ "$COMMAND" = "sync" ]; then
    gmux_sync "$@"
elif [ "$COMMAND" = "rsync" ]; then
    gmux_rsync "$@"
else
    elog "'$COMMAND': no such command"
    exit 1
fi
